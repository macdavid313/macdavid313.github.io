<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Common Lisp 中的 'map'</title><meta name=author content="Tianyu Gu"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/img/favicon.ico><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Xanh+Mono&display=swap" rel=stylesheet><style type=text/css>body{font-family:monospace}code{color:#000;font-family:fira code,monospace;font-size:small}blockquote{font-family:xanh mono,monospace}figure{margin-top:3%;margin-bottom:3%;margin-left:5%;margin-right:5%}table,th,td{border:1px solid #fff}</style></head><body><header>=========<br>== <a href=https://macdavid313.xyz/>gty</a> ==<br>=========<div style=float:right>You gotta go away to come back.</div><br><p><nav><a href=/about/><b>about</b></a>.
<a href=/wiki/><b>wiki</b></a>.
<a href=/posts/><b>posts</b></a>.
<a href=/tags/><b>tags</b></a>.
<a href=/cat/><b>cat</b></a>.
<a href=/playlists/><b>playlists</b></a>.</nav></p></header><main><article><h1>Common Lisp 中的 'map'</h1><b><time>Nov 1, 2016, Tuesday</time></b>
<a href=/tags/lisp>lisp</a><div><blockquote><p>In many programming languages, map is the name of a higher-order function that applies a given function to each element of a list, returning a list of results in the same order. It is often called apply-to-all when considered in functional form. The concept of a map is not limited to lists: it works for sequential containers, tree-like containers, or even abstract containers such as futures and promises. —— Wikipedia<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><h1 id=scheme-中的-map>Scheme 中的 map</h1><p><code>map</code> 在 Lisp 语言中是一个经典的操作符。在包括《计算机程序的构造与解释》的诸多教材里，<code>map</code> 都作为一个使用<strong>高阶函数</strong>的经典范例。我们首先考察，在“短小精悍”的 Scheme 语言中，<code>map</code> 的“签名”与使用方法如下：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=color:#60a0b0;font-style:italic>;;; procedure: (map procedure list1 list2 ...)</span>
<span style=color:#60a0b0;font-style:italic>;;; returns: list of results</span>
(<span style=color:#007020>map </span><span style=color:#bb60d5>abs</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>-2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>-4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>-6</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4 5 6)</span>
(<span style=color:#007020>map </span><span style=color:#bb60d5>+</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>) <span style=color:#666>&#39;</span>(<span style=color:#40a070>3</span> <span style=color:#40a070>2</span> <span style=color:#40a070>1</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (4 4 4)</span>
</code></pre></div><p><code>map</code> 的作用在此很明了：对于列表中的每个元素应用一遍绝对值函数<code>abs</code>，然后返回一个由结果组成的列表。那么这个返回的列表和作为参数的列表之间有没有关系呢？</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme>(<span style=color:#007020;font-weight:700>define </span><span style=color:#bb60d5>lst-1</span> (<span style=color:#007020>list </span><span style=color:#40a070>1</span> <span style=color:#40a070>-2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>-4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>-6</span>))
(<span style=color:#007020;font-weight:700>define </span><span style=color:#bb60d5>lst-2</span> (<span style=color:#007020>map </span><span style=color:#bb60d5>abs</span> <span style=color:#bb60d5>lst-1</span>))
<span style=color:#bb60d5>lst-2</span> <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4 5 6)</span>
(<span style=color:#007020>eq? </span><span style=color:#bb60d5>lst-1</span> <span style=color:#bb60d5>lst-2</span>) <span style=color:#60a0b0;font-style:italic>;; =&gt; #f</span>
(<span style=color:#007020>set-car! </span><span style=color:#bb60d5>lst-1</span> <span style=color:#40a070>-1000</span>)
<span style=color:#bb60d5>lst-1</span> <span style=color:#60a0b0;font-style:italic>;; =&gt; (-1000 -2 3 -4 5 -6)</span>
<span style=color:#bb60d5>lst-2</span> <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4 5 6)</span>
</code></pre></div><p>可以看到，<code>map</code> 并不会带来所谓的“副作用”；也就是说，<code>map</code> 不会肆意造成任何 <code>mutation</code>。<code>map</code> 所映射出来的列表完全是一个新的列表。事实上，<code>map</code> 完全可以由下面几行代码所实现<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; am example implementation of `map` in Scheme</span>
(<span style=color:#bb60d5>define</span> <span style=color:#06287e>map</span>
  (<span style=color:#007020>lambda</span> (<span style=color:#bb60d5>f</span> <span style=color:#bb60d5>ls</span> <span style=color:#666>.</span> <span style=color:#bb60d5>more</span>)
    (<span style=color:#007020;font-weight:700>if</span> (<span style=color:#bb60d5>null?</span> <span style=color:#bb60d5>more</span>)
        (<span style=color:#007020;font-weight:700>let</span> <span style=color:#bb60d5>map1</span> (<span style=color:#bb60d5>[ls</span> <span style=color:#bb60d5>ls]</span>)
          (<span style=color:#007020;font-weight:700>if</span> (<span style=color:#bb60d5>null?</span> <span style=color:#bb60d5>ls</span>)
              <span style=color:#666>&#39;</span>()
              (<span style=color:#0e84b5;font-weight:700>cons</span> (<span style=color:#bb60d5>f</span> (<span style=color:#06287e>car</span> <span style=color:#bb60d5>ls</span>))
                    (<span style=color:#bb60d5>map1</span> (<span style=color:#06287e>cdr</span> <span style=color:#bb60d5>ls</span>)))))
        (<span style=color:#007020;font-weight:700>let</span> <span style=color:#bb60d5>map-more</span> (<span style=color:#bb60d5>[ls</span> <span style=color:#bb60d5>ls]</span> <span style=color:#bb60d5>[more</span> <span style=color:#bb60d5>more]</span>)
          (<span style=color:#007020;font-weight:700>if</span> (<span style=color:#bb60d5>null?</span> <span style=color:#bb60d5>ls</span>)
              <span style=color:#666>&#39;</span>()
              (<span style=color:#0e84b5;font-weight:700>cons</span>
               (<span style=color:#06287e>apply</span> <span style=color:#bb60d5>f</span> (<span style=color:#06287e>car</span> <span style=color:#bb60d5>ls</span>) (<span style=color:#06287e>map</span> <span style=color:#06287e>car</span> <span style=color:#bb60d5>more</span>))
               (<span style=color:#bb60d5>map-more</span> (<span style=color:#06287e>cdr</span> <span style=color:#bb60d5>ls</span>) (<span style=color:#06287e>map</span> <span style=color:#06287e>cdr</span> <span style=color:#bb60d5>more</span>))))))))
</code></pre></div><p>也许有人会说，<code>map</code> 这种没有“副作用”的机制是否也会随之带来较大的开销。这种担忧的确是值得考量的。**在我的理解中，函数式编程的代价即在于此：在效率上的牺牲并不代表我们要鼓吹“消除副作用”、“消除 mutation”；函数式的真正意义在于帮助程序员更好的带来我们想要的“副作用”、“mutation”，哪怕牺牲一些性能。**如果一个程序在运行之后什么也没有改变，那还有什么意义呢？</p><p>在这个问题上，“麻雀虽小五脏俱全”的 Scheme 提供了一个 <code>for-each</code> 函数：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=color:#60a0b0;font-style:italic>;;; procedure: (for-each procedure list1 list2 ...)</span>
<span style=color:#60a0b0;font-style:italic>;;; returns: unspecified</span>
(<span style=color:#007020>for-each </span><span style=color:#bb60d5>display</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; （屏幕上输出）123</span>
</code></pre></div><p><code>for-each</code> 的实现<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>较之 <code>map</code> 则显得更简洁一些：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scheme data-lang=scheme><span style=color:#60a0b0;font-style:italic>;;; am example implementation of `for-each` in Scheme</span>
(<span style=color:#007020;font-weight:700>define </span><span style=color:#bb60d5>for-each</span>
  (<span style=color:#007020;font-weight:700>lambda </span>(<span style=color:#06287e>f</span> <span style=color:#bb60d5>ls</span> <span style=color:#666>.</span> <span style=color:#bb60d5>more</span>)
    (<span style=color:#007020;font-weight:700>do </span>([<span style=color:#bb60d5>ls</span> <span style=color:#bb60d5>ls</span> (<span style=color:#007020>cdr </span><span style=color:#bb60d5>ls</span>)] [<span style=color:#bb60d5>more</span> <span style=color:#bb60d5>more</span> (<span style=color:#007020>map </span><span style=color:#bb60d5>cdr</span> <span style=color:#bb60d5>more</span>)])
        ((<span style=color:#007020>null? </span><span style=color:#bb60d5>ls</span>))
      (<span style=color:#007020>apply </span><span style=color:#bb60d5>f</span> (<span style=color:#007020>car </span><span style=color:#bb60d5>ls</span>) (<span style=color:#007020>map </span><span style=color:#bb60d5>car</span> <span style=color:#bb60d5>more</span>)))))
</code></pre></div><h1 id=common-lisp-中的-map>Common Lisp 中的 map</h1><p>Common Lisp 虽然在设计方面受到 Scheme 的诸多影响，但是作为一门野心勃勃的、试图涵盖与统一所有 Lisp 方言的语言，Common Lisp 中和 <code>map</code> 有关的函数多达 9 个<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>：</p><ol><li>map</li><li>map-into</li><li>mapcar</li><li>mapc</li><li>maplist</li><li>mapl</li><li>mapcan</li><li>mapcon</li><li>maphash</li></ol><p>接下来，我们按照上面列出的顺序逐个考察。首先给出其语法和示例用法，接着作出比较与讨论。</p><h2 id=map>map</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAP</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; map result-type function &amp;rest sequences+ =&gt; result</span>
(<span style=color:#06287e>map</span> <span style=color:#517918>&#39;list</span> <span style=color:#06287e>#&#39;abs</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>-2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>-4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>-6</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4 5 6)</span>
(<span style=color:#06287e>map</span> <span style=color:#517918>&#39;vector</span> <span style=color:#06287e>#&#39;abs</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>-2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>-4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>-6</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; #(1 2 3 4 5 6)</span>
(<span style=color:#06287e>map</span> <span style=color:#517918>&#39;vector</span> <span style=color:#06287e>#&#39;char-code</span> <span style=color:#4070a0>&#34;abcdefg&#34;</span>) <span style=color:#60a0b0;font-style:italic>;; =&gt; #(97 98 99 100 101 102 103)</span>
(<span style=color:#06287e>map</span> <span style=color:#517918>&#39;string</span> <span style=color:#06287e>#&#39;code-char</span> <span style=color:#666>#(</span><span style=color:#40a070>97</span> <span style=color:#40a070>98</span> <span style=color:#40a070>99</span> <span style=color:#40a070>100</span> <span style=color:#40a070>101</span> <span style=color:#40a070>102</span> <span style=color:#40a070>103</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; &#34;abcdefg&#34;</span>
</code></pre></div><p>这个 <code>map</code> 和 Scheme 中的 <code>map</code> 颇为相似。但是，第一个参数在此为返回类型，并且这个类型必须是序列（<em>Sequence</em>）的子类型；第二个参数才是映射函数，并且其参数的个数与接下来所提供的序列的个数应当一致。也就是说，这个 <code>map</code> 既可以用来映射列表，也可以用来映射数组。Common Lisp 语言本身在设计上的<strong>正交性</strong>在此也有所体现了。</p><p>值得注意的是，当第一个参数为 <code>nil</code> 的时候，<code>map</code> 便可以“模拟” Scheme 中 <code>for-each</code> 的行为：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; map returns nil if result-type is nil,</span>
<span style=color:#60a0b0;font-style:italic>;;; which means no result sequence is to be produced;</span>
<span style=color:#60a0b0;font-style:italic>;;; in this case the function is invoked only for effect.</span>
(<span style=color:#06287e>map</span> <span style=color:#60add5>nil</span> <span style=color:#06287e>#&#39;prin1</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; 屏幕上输出 123，返回 NIL</span>
</code></pre></div><p>最后要指出的是，在这里，各序列的长度不一定要完全一致，<code>map</code> 会以长度最短的序列为基准。我们姑且称之为“最短法则”。也就是说，如果参数中第一个序列长度为 10，第二个为 8，那么 <code>map</code> 在映射到各序列中第八个元素后就停止工作了：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; when length of sequences is not the same ...</span>
(<span style=color:#06287e>map</span> <span style=color:#517918>&#39;vector</span> <span style=color:#06287e>#&#39;*</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>6</span> <span style=color:#40a070>7</span> <span style=color:#40a070>8</span> <span style=color:#40a070>9</span> <span style=color:#40a070>10</span>)
                 <span style=color:#666>#(</span><span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>6</span> <span style=color:#40a070>7</span> <span style=color:#40a070>8</span>))
<span style=color:#60a0b0;font-style:italic>;; =&gt; #(1 4 9 16 25 36 49 64)</span>
</code></pre></div><p>更多信息请阅读 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node143.html#SECTION001820000000000000000>CLtL2</a> 以及 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_map.htm#map>HyperSpec</a> 中的相关内容。</p><h2 id=map-into>map-into</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAP-INTO</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; map-into result-sequence function &amp;rest sequences =&gt; result-sequence</span>
(<span style=color:#007020>defvar</span> *lst* (<span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#40a070>1</span> <span style=color:#40a070>-2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>-4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>-6</span>))
(<span style=color:#06287e>map-into</span> *lst* <span style=color:#06287e>#&#39;abs</span> *lst*) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4 5 6)</span>
*lst* <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4 5 6)</span>
(<span style=color:#06287e>map-into</span> *lst* <span style=color:#06287e>#&#39;*</span> *lst* *lst*) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 4 9 16 25 36)</span>
*lst* <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 4 9 16 25 36)</span>
</code></pre></div><p><code>map-into</code> 和 <code>map</code> 很类似，并且都是可以在任意序列对象上操作的函数。但其区别在于，<code>map-into</code> 永远都会<strong>改变一个现有序列的状态</strong>，而不是像 <code>map</code> 一样会生成一个新的序列。<a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_map_in.htm#map-into>HyperSpec</a> 上有一小段代码可以作为 <code>map-into</code> 的实现方式：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; an example implementation of map-into</span>
(<span style=color:#007020>defun</span> <span style=color:#06287e>map-into</span> (<span style=color:#bb60d5>result-sequence</span> <span style=color:#0e84b5;font-weight:700>function</span> <span style=color:#007020;font-weight:700>&amp;rest</span> <span style=color:#bb60d5>sequences</span>)
  (<span style=color:#007020>loop</span> <span style=color:#bb60d5>for</span> <span style=color:#bb60d5>index</span> <span style=color:#bb60d5>below</span> (<span style=color:#06287e>apply</span> <span style=color:#06287e>#&#39;min</span>
                               (<span style=color:#06287e>length</span> <span style=color:#bb60d5>result-sequence</span>)
                               (<span style=color:#06287e>mapcar</span> <span style=color:#06287e>#&#39;length</span> <span style=color:#bb60d5>sequences</span>))
     <span style=color:#007020>do</span> (<span style=color:#007020>setf</span> (<span style=color:#06287e>elt</span> <span style=color:#bb60d5>result-sequence</span> <span style=color:#bb60d5>index</span>)
              (<span style=color:#06287e>apply</span> <span style=color:#0e84b5;font-weight:700>function</span>
                     (<span style=color:#06287e>mapcar</span> <span style=color:#06287e>#&#39;</span>(<span style=color:#007020>lambda</span> (<span style=color:#bb60d5>seq</span>) (<span style=color:#06287e>elt</span> <span style=color:#bb60d5>seq</span> <span style=color:#bb60d5>index</span>))
                             <span style=color:#bb60d5>sequences</span>))))
     <span style=color:#bb60d5>result-sequence</span>)
</code></pre></div><p>由此可见，</p><ul><li>使用 <em>map-into</em> 的目的主要就在于其带来的“副作用”；</li><li><em>map-into</em> 的“迭代”次数取决于 <em>result-sequence</em> 和所有 <em>sequences</em> 中长度最小的，也就是说，如果最小长度是 <em>n</em>，那么在映射完第 <em>n</em> 次之后，<em>map-into</em> 就会停止工作。</li></ul><p>另外要注意的是，如果 <code>result-sequence</code> 是一个拥有填充指针（<em>Fill Pointer</em>）的向量（<em>Vector</em>），那么 <code>map-into</code> 在工作时并不会考虑这个填充指针的大小；而在映射完成后，这个填充指针会被重新设置成映射函数被调用的次数：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; CLtL2:</span>
<span style=color:#60a0b0;font-style:italic>;;; If result-sequence is a vector with a fill pointer,</span>
<span style=color:#60a0b0;font-style:italic>;;; the fill pointer is ignored when deciding how many iterations to perform,</span>
<span style=color:#60a0b0;font-style:italic>;;; and afterwards the fill pointer is set to the number of times function was applied.</span>
(<span style=color:#007020>defvar</span> *vector* (<span style=color:#06287e>make-array</span> <span style=color:#40a070>5</span> <span style=color:#517918>:initial-element</span> <span style=color:#40a070>0</span> <span style=color:#517918>:fill-pointer</span> <span style=color:#40a070>2</span>))
*vector* <span style=color:#60a0b0;font-style:italic>;; =&gt; #(0 0)</span>
(<span style=color:#06287e>length</span> *vector*) <span style=color:#60a0b0;font-style:italic>;; =&gt; 2</span>
(<span style=color:#06287e>array-total-size</span> *vector*) <span style=color:#60a0b0;font-style:italic>;; =&gt; 5</span>
(<span style=color:#06287e>fill-pointer</span> *vector*) <span style=color:#60a0b0;font-style:italic>;; =&gt; 2</span>
(<span style=color:#06287e>map-into</span> *vector* <span style=color:#06287e>#&#39;*</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span>) <span style=color:#666>#(</span><span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span> <span style=color:#40a070>5</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; #(1 4 9 16)</span>
(<span style=color:#06287e>fill-pointer</span> *vector*) <span style=color:#60a0b0;font-style:italic>;; =&gt; 4</span>
</code></pre></div><p>在这里也许有人就会发现了，<code>*vector*</code> 在初始化长度明明是 2，按照“最短法则”，<code>map-into</code>不应该迭代两次就停止工作了吗？让我们再来看一下语言标准 CLtL2 中的原文：</p><blockquote><p>If result-sequence and the other argument sequences are not all the same length, the iteration terminates when the shortest sequence is exhausted. – Section 14.2, CLtL2.</p></blockquote><p>所以，虽然 <code>*vector*</code> 的长度一开始为 2，但是在映射完第二个元素后，<code>*vector*</code> 并没有 <strong>exhausted<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></strong>。上文中，HyperSpec 所给出的实现并未能很好体现这一点，故在此特别指明。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_map_in.htm#map-into>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node143.html#SECTION001820000000000000000>CltL2</a> 中的相关内容。</p><h2 id=mapcar>mapcar</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAPCAR</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; mapcar function &amp;rest lists+ =&gt; result-list</span>
(<span style=color:#06287e>mapcar</span> <span style=color:#06287e>#&#39;abs</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>-2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>-4</span> <span style=color:#40a070>5</span> <span style=color:#40a070>-6</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4 5 6)</span>
(<span style=color:#06287e>mapcar</span> <span style=color:#06287e>#&#39;*</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>) <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 4 9)</span>
(<span style=color:#06287e>mapcar</span> <span style=color:#06287e>#&#39;*</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span> <span style=color:#40a070>5</span>) <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 4 9)</span>
</code></pre></div><p><code>mapcar</code> 只能操作于列表之上，所以它的行为和 Scheme 中的 <code>map</code> 完全类似。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapcar>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node143.html#SECTION001820000000000000000>CltL2</a> 中的相关内容。</p><h2 id=mapc>mapc</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAPC</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; mapc function &amp;rest lists+ =&gt; list-1</span>
(<span style=color:#06287e>mapc</span> <span style=color:#06287e>#&#39;prin1</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; 屏幕上输出 123，返回 (1 2 3)</span>
(<span style=color:#06287e>mapc</span> <span style=color:#06287e>#&#39;+</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>) <span style=color:#666>&#39;</span>(<span style=color:#40a070>3</span> <span style=color:#40a070>2</span> <span style=color:#40a070>1</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3)</span>
</code></pre></div><p><code>mapc</code> 只能操作于列表之上，且其行为几乎和 Scheme 的 <code>for-each</code> 一致，于是也和第一个参数为 <code>nil</code> 时的 <code>map</code> 类似。但不同的是，<code>mapc</code> 永远都会返回第一个列表的值，这也意味着 <code>mapc</code> 至少要接受三个参数。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapc>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</p><h2 id=maplist>maplist</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAPLIST</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; maplist function &amp;rest lists+ =&gt; result-list</span>
(<span style=color:#06287e>maplist</span> <span style=color:#06287e>#&#39;append</span> <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span>) <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span>) <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span>))
<span style=color:#60a0b0;font-style:italic>;; =&gt; ((1 2 3 4 1 2 3 1 2) (2 3 4 2 3 2))</span>
</code></pre></div><p><code>maplist</code> 只能操作于列表，理解它的关键在于，每一次映射函数得到的参数先是列表（们）本身，接着是列表（们）的 <code>cdr</code>，再接着是列表（们） <code>cdr</code> 的 <code>cdr</code>，直至在列表（们）碰到第一个 <code>nil</code> 后 <code>maplist</code> 停止工作。在此，我们不妨拥 Scheme 来做一个演示：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; an example implementation of maplist in Scheme(define maplist(lambda (f lst . more)(if (null? more)(let map1 ([lst lst])(if (null? lst)&#39;()(cons (f lst)(map1 (cdr lst)))))(let map-more ([lst lst][more more])(if (null? lst)&#39;()(if (member &#39;() more)&#39;()(cons (apply f lst more)(map-more (cdr lst) (map cdr more)))))))))</span>
</code></pre></div><p>更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#maplist>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</p><h2 id=mapl>mapl</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAPL</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; mapl function &amp;rest lists+ =&gt; list-1</span>
(<span style=color:#007020>defvar</span> *lst* <span style=color:#60add5>nil</span>)
(<span style=color:#06287e>mapl</span> <span style=color:#06287e>#&#39;</span>(<span style=color:#007020>lambda</span> (<span style=color:#bb60d5>x</span>) (<span style=color:#007020>push</span> <span style=color:#bb60d5>x</span> *lst*)) <span style=color:#666>&#39;</span>(<span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span>)) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 2 3 4)</span>
*lst* <span style=color:#60a0b0;font-style:italic>;; =&gt; ((4) (3 4) (2 3 4) (1 2 3 4))</span>
</code></pre></div><p><code>mapl</code> 只能操作于列表之上，其行为和 <code>maplist</code> 类似，但是 <code>mapl</code> 并不会把每次的映射结果收集到一个新列表里，反而只会返回参数 <code>lists</code> 中的第一个列表。可以猜到的是，这个函数是为“副作用”而准备的。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapl>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</p><h2 id=mapcan>mapcan</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAPCAN</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; mapcan function &amp;rest lists+ =&gt; concatenated-results</span>
(<span style=color:#06287e>mapcan</span> <span style=color:#06287e>#&#39;</span>(<span style=color:#007020>lambda</span> (<span style=color:#bb60d5>x</span>) (<span style=color:#007020>and</span> (<span style=color:#06287e>numberp</span> <span style=color:#bb60d5>x</span>) (<span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#bb60d5>x</span>)))
        <span style=color:#666>&#39;</span>(<span style=color:#bb60d5>a</span> <span style=color:#40a070>1</span> <span style=color:#bb60d5>b</span> <span style=color:#bb60d5>c</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span> <span style=color:#bb60d5>d</span> <span style=color:#40a070>5</span>))
<span style=color:#60a0b0;font-style:italic>;;; =&gt; (1 3 4 5)</span>
(<span style=color:#06287e>mapcar</span> <span style=color:#06287e>#&#39;</span>(<span style=color:#007020>lambda</span> (<span style=color:#bb60d5>x</span>) (<span style=color:#007020>and</span> (<span style=color:#06287e>numberp</span> <span style=color:#bb60d5>x</span>) (<span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#bb60d5>x</span>)))
        <span style=color:#666>&#39;</span>(<span style=color:#bb60d5>a</span> <span style=color:#40a070>1</span> <span style=color:#bb60d5>b</span> <span style=color:#bb60d5>c</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span> <span style=color:#bb60d5>d</span> <span style=color:#40a070>5</span>))
<span style=color:#60a0b0;font-style:italic>;;; =&gt; (NIL (1) NIL NIL (3) (4) NIL (5))</span>
(<span style=color:#06287e>apply</span> <span style=color:#06287e>#&#39;nconc</span> <span style=color:#666>&#39;</span>(<span style=color:#60add5>NIL</span> (<span style=color:#40a070>1</span>) <span style=color:#60add5>NIL</span> <span style=color:#60add5>NIL</span> (<span style=color:#40a070>3</span>) (<span style=color:#40a070>4</span>) <span style=color:#60add5>NIL</span> (<span style=color:#40a070>5</span>))) <span style=color:#60a0b0;font-style:italic>;; =&gt; (1 3 4 5)</span>
</code></pre></div><p><code>mapcan</code> 只能操作于列表之上。简单来说，<code>mapcan</code> 是把 <code>mapcar</code> 的结果应用于 <code>nconc</code> 后的返回值：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp>(<span style=color:#007020>defun</span> <span style=color:#06287e>mapcan</span> (<span style=color:#0e84b5;font-weight:700>function</span> <span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#007020;font-weight:700>&amp;rest</span> <span style=color:#bb60d5>more-lists</span>)
  (<span style=color:#06287e>apply</span> <span style=color:#06287e>#&#39;nconc</span>
         (<span style=color:#06287e>apply</span> <span style=color:#06287e>#&#39;mapcar</span> <span style=color:#0e84b5;font-weight:700>function</span> <span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#bb60d5>more-lists</span>)))
</code></pre></div><p>由于使用了 <code>nconc</code> 函数，<code>mapcan</code> 也随之带来了副作用。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapcan>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</p><h2 id=mapcon>mapcon</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAPCON</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; mapcon function &amp;rest lists+ =&gt; concatenated-results</span>
(<span style=color:#06287e>mapcon</span> <span style=color:#06287e>#&#39;</span><span style=color:#0e84b5;font-weight:700>list</span> (<span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#40a070>1</span> <span style=color:#40a070>2</span> <span style=color:#40a070>3</span> <span style=color:#40a070>4</span>))
<span style=color:#60a0b0;font-style:italic>;; =&gt; ((1 2 3 4) (2 3 4) (3 4) (4))</span>
</code></pre></div><p><code>mapcon</code> 同样也只能操作于列表之上，类似的，<code>mapcan</code> 是把 <code>maplist</code> 的结果应用于 <code>nconc</code> 后的返回值：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp>(<span style=color:#007020>defun</span> <span style=color:#06287e>mapcon</span> (<span style=color:#0e84b5;font-weight:700>function</span> <span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#007020;font-weight:700>&amp;rest</span> <span style=color:#bb60d5>more-lists</span>)
  (<span style=color:#06287e>apply</span> <span style=color:#06287e>#&#39;nconc</span>
         (<span style=color:#06287e>apply</span> <span style=color:#06287e>#&#39;maplist</span> <span style=color:#0e84b5;font-weight:700>list</span> <span style=color:#bb60d5>more-lists</span>)))
</code></pre></div><p>同样的，由于使用了 <code>nconc</code> 函数，<code>mapcon</code> 也随之带来了副作用。更多信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm#mapcon>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node90.html#SECTION001184000000000000000>CLtL2</a> 中的相关内容。</p><h2 id=maphash>maphash</h2><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Function MAPHASH</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; maphash function hash-table =&gt; nil</span>
(<span style=color:#007020>defvar</span> *lst* <span style=color:#666>&#39;</span>(<span style=color:#bb60d5>a</span> <span style=color:#bb60d5>b</span> <span style=color:#bb60d5>c</span> <span style=color:#bb60d5>d</span> <span style=color:#bb60d5>e</span> <span style=color:#bb60d5>f</span> <span style=color:#bb60d5>g</span>))
(<span style=color:#007020>defvar</span> *table* (<span style=color:#06287e>make-hash-table</span>))
(<span style=color:#007020>dolist</span> (<span style=color:#bb60d5>sym</span> *lst*)
  (<span style=color:#007020>setf</span> (<span style=color:#06287e>gethash</span> <span style=color:#bb60d5>sym</span> *table*) (<span style=color:#06287e>symbol-name</span> <span style=color:#bb60d5>sym</span>)))
(<span style=color:#06287e>maphash</span> <span style=color:#06287e>#&#39;</span>(<span style=color:#007020>lambda</span> (<span style=color:#bb60d5>k</span> <span style=color:#bb60d5>v</span>) (<span style=color:#06287e>format</span> <span style=color:#60add5>t</span> <span style=color:#4070a0>&#34;~A =&gt; ~S~%&#34;</span> <span style=color:#bb60d5>k</span> <span style=color:#bb60d5>v</span>))
         *table*)
<span style=color:#60a0b0;font-style:italic>;;; 屏幕输出：</span>
<span style=color:#60a0b0;font-style:italic>;;; A =&gt; &#34;A&#34;</span>
<span style=color:#60a0b0;font-style:italic>;;; B =&gt; &#34;B&#34;</span>
<span style=color:#60a0b0;font-style:italic>;;; C =&gt; &#34;C&#34;</span>
<span style=color:#60a0b0;font-style:italic>;;; D =&gt; &#34;D&#34;</span>
<span style=color:#60a0b0;font-style:italic>;;; E =&gt; &#34;E&#34;</span>
<span style=color:#60a0b0;font-style:italic>;;; F =&gt; &#34;F&#34;</span>
<span style=color:#60a0b0;font-style:italic>;;; G =&gt; &#34;G&#34;</span>
<span style=color:#60a0b0;font-style:italic>;;; 返回： NIL</span>
</code></pre></div><p><code>maphash</code> 是专门用来操作哈希表的函数。其第一个参数必定为一个双参函数，在每一次映射中，这个函数接受一对键值，并完成一次映射。对于这个映射函数所带来的潜在的副作用，语言规范中特别强调：</p><blockquote><p>If entries are added to or deleted from the hash table while a maphash is in progress, the results are unpredictable, with one exception: if the function calls remhash to remove the entry currently being processed by the function, or performs a setf of gethash on that entry to change the associated value, then those operations will have the intended effect. For example:
;;; Alter every entry in MY-HASH-TABLE, replacing the value with
;;; its square root. Entries with negative values are removed.
(maphash #'(lambda (key val)
(if (minusp val)
(remhash key my-hash-table)
(setf (gethash key my-hash-table) (sqrt val))))
my-hash-table)
– Section 16.1, CLtL2</p></blockquote><p>也就是说，移除一对键值，或者修改当前键所对应的值是可以的，而其他的行为则就是未规范的了。值得一提的是，其实对于哈希表的迭代，Common Lisp 提供了更通用的 <code>with-hash-table-iterator</code>，以至于 <code>maphash</code> 其实可以基于它来实现：</p><div class=highlight><pre style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=color:#60a0b0;font-style:italic>;;; Macro WITH-HASH-TABLE-ITERATOR</span>
<span style=color:#60a0b0;font-style:italic>;;; Syntax:</span>
<span style=color:#60a0b0;font-style:italic>;;; with-hash-table-iterator (name hash-table) declaration* form* =&gt; result*</span>
(<span style=color:#007020>defun</span> <span style=color:#06287e>maphash</span> (<span style=color:#0e84b5;font-weight:700>function</span> <span style=color:#0e84b5;font-weight:700>hash-table</span>)
  (<span style=color:#007020>with-hash-table-iterator</span> (<span style=color:#bb60d5>next-entry</span> <span style=color:#0e84b5;font-weight:700>hash-table</span>)
    (<span style=color:#007020>loop</span> (<span style=color:#007020>multiple-value-bind</span> (<span style=color:#bb60d5>more</span> <span style=color:#bb60d5>key</span> <span style=color:#bb60d5>value</span>) (<span style=color:#bb60d5>next-entry</span>)
            (<span style=color:#007020>unless</span> <span style=color:#bb60d5>more</span> (<span style=color:#007020>return</span> <span style=color:#60add5>nil</span>))
            (<span style=color:#06287e>funcall</span> <span style=color:#0e84b5;font-weight:700>function</span> <span style=color:#bb60d5>key</span> <span style=color:#bb60d5>value</span>)))))
</code></pre></div><p>更多相关信息请阅读 <a href=http://www.lispworks.com/documentation/HyperSpec/Body/f_maphas.htm#maphash>HyperSpec</a> 和 <a href=http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node155.html>CLtL2</a> 中的相关内容。</p><h1 id=总结>总结</h1><p>下面，我们从两个维度来观察这 9 个函数，并以此收结束本文。</p><h2 id=操作对象>操作对象</h2><table><thead><tr><th style=text-align:left>操作对象</th><th style=text-align:left>函数名</th></tr></thead><tbody><tr><td style=text-align:left>哈希表</td><td style=text-align:left>maphash</td></tr><tr><td style=text-align:left>列表</td><td style=text-align:left>mapcar, maplist, mapc, mapl, mapcan, mapcon</td></tr><tr><td style=text-align:left>序列</td><td style=text-align:left>map, map-into</td></tr></tbody></table><p>请注意，“列表”是“序列”的子类型，因此 <code>map</code> 与 <code>map-into</code> 具有更高的通用性（<em>General</em>）。</p><h2 id=副作用>副作用</h2><p>**首先需要说明，这里的“副作用”指的是这个函数到底是为了得到返回值，还是为了带来“副作用”。**换句话说，映射函数 <code>function</code> 可以尽管带来 <code>mutation</code>，但那极有可能是一种不良的编码风格；可在使用例如 <code>mapc</code> 的函数时，如果映射函数不带有任何“副作用”，那么它只会返回一个和参数一模一样的列表，这样的意义何在呢？</p><table><thead><tr><th style=text-align:left>函数名</th><th style=text-align:left>注解</th></tr></thead><tbody><tr><td style=text-align:left>map</td><td style=text-align:left>当第一个参数为 nil 时，可以认为目的是带来“副作用”</td></tr><tr><td style=text-align:left>map-into</td><td style=text-align:left>总是会修改一个现有序列的状态，有副作用</td></tr><tr><td style=text-align:left>mapcar</td><td style=text-align:left>无副作用</td></tr><tr><td style=text-align:left>mapc</td><td style=text-align:left>类似 Scheme 中的 for-each，有副作用</td></tr><tr><td style=text-align:left>maplist</td><td style=text-align:left>无副作用</td></tr><tr><td style=text-align:left>mapl</td><td style=text-align:left>原因类似 mapc，有副作用</td></tr><tr><td style=text-align:left>mapcan</td><td style=text-align:left>可视为 mapcar 的延展，我们更想得到返回值，故认为无副作用<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></td></tr><tr><td style=text-align:left>mapcon</td><td style=text-align:left>可视为 maplist 的延展，我们更想得到返回值，故认为无副作用</td></tr><tr><td style=text-align:left>maphash</td><td style=text-align:left>语言标准中只规范了两种可行的副作用，在此不特地做区分</td></tr></tbody></table><p>所以，我的个人结论是：</p><table><thead><tr><th style=text-align:left>区分</th><th style=text-align:left>函数名</th></tr></thead><tbody><tr><td style=text-align:left>为了带来副作用的函数</td><td style=text-align:left>mapc, mapl, map-into, 以及第一个参数为 nil 的 map</td></tr><tr><td style=text-align:left>无副作用的函数</td><td style=text-align:left>mapcar, maplist, mapcan, mapcon, 以及第一个参数不为 nil 的 map</td></tr><tr><td style=text-align:left>只能带来特定的副作用</td><td style=text-align:left>maphash</td></tr></tbody></table><p>之所以要以“目的”来对“副作用”的含义进行说明，是希望在此能帮助读者更好的理解这些 <code>map</code> 操作符，理解语言设计者的用意。虽说“仁者见仁，智者见智”，但是我们还是希望在 Common Lisp 的编码风格上有着一定的规范，尤其是建议不要乱用、滥用这些操作符到不恰当的地方。</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>参见 Wikipedia, <a href=https://en.wikipedia.org/wiki/Map_(higher-order_function)>https://en.wikipedia.org/wiki/Map_(higher-order_function)</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>参见 <a href=http://www.scheme.com/tspl4/control.html#./control:h5>Section 5.5</a> Mapping and Folding, The Scheme Programming Language 4th Edition, R. Kent Dybvig. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>同样参见 <a href=http://www.scheme.com/tspl4/control.html#./control:h5>Section 5.5</a> Mapping and Folding, The Scheme Programming Language 4th Edition, R. Kent Dybvig. <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>这样的说法不算很严谨。毕竟，Scheme 中的 <code>map</code> 只能操作列表，而这里列出的这9个则能操作包括列表、数组，甚至哈希表。所以，这里“有关”的含义仅仅是名字里或者概念上和 <code>map</code> “有关”。 <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>尽管如此，关于什么才是 <strong>exhausted</strong>，CLtL2 并没有做出定义。想在这个问题上探个究竟的朋友请参考 SBCL 中的<a href=https://github.com/sbcl/sbcl/blob/master/src/code/seq.lisp#L1270>相关代码</a>，此处不做展开了。 <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>基于上文对“副作用”的界定，这样的区分是有道理的。但是仍需注意的是，<code>mapcan</code> 以及接下来的 <code>mapcon</code> 都使用了破坏性函数 <code>nconc</code>，所以 <code>mapcan</code> 与 <code>mapcon</code> 也是有破坏性的。引用 CLtL2 中的话来说就是：<em>“Remember that nconc is a destructive operation, and therefore so are mapcan and mapcon; the lists returned by the function are altered in order to concatenate them.”</em> <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/10-years-after-gaokao/>十年后，回望高考和高中的时光</a></li><li><a href=/posts/wind-river-movie/>猎凶风河谷（电影）</a></li><li><a href=/posts/ibm-model-m-arrived/>IBM Model M 来了</a></li><li><a href=/posts/from-push-up-to-pull-up/>从"俯卧撑"到"引体向上"</a></li><li><a href=/posts/lisp-while-lang/>Common Lisp Solution to While Language</a></li></ul></div></div></aside><footer><p>&copy; 2021 <a href=https://macdavid313.xyz/><b>gty</b></a>.
<a href=mailto:macdavid313@gmail.com><b>email</b></a>.
<a href=/assets/pgp-public.txt><b>PGP</b></a>.
<a href=https://github.com/macdavid313><b>github</b></a>.
<a href=https://www.instagram.com/davidgu357/><b>instagram</b></a>.</p></footer></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lisp on gty</title><link>https://macdavid313.xyz/tags/lisp/</link><description>Recent content in lisp on gty</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 12 Apr 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://macdavid313.xyz/tags/lisp/index.xml" rel="self" type="application/rss+xml"/><item><title>Common Lisp Solution to While Language</title><link>https://macdavid313.xyz/posts/lisp-while-lang/</link><pubDate>Fri, 12 Apr 2019 00:00:00 +0000</pubDate><guid>https://macdavid313.xyz/posts/lisp-while-lang/</guid><description>I have written a solution to Hackerrank&amp;#39;s problem &amp;#34;While Language&amp;#34; in Common Lisp, solely for fun. Several years ago, I have solved it using OCaml.
Where does &amp;#39;fun&amp;#39; come from? In Lisp, it&amp;#39;s really easy to construct ASTs. In a lot of scenarios, you can effortlessly transpile source code into Lisp forms and then ask your Lisp implementation to analyse, optimise and execute it. For example, after lexing and parsing, I have written a function gen-lisp-code to expose the transpiled Lisp code:</description></item><item><title>Notes on Deploying Common Lisp Web Services</title><link>https://macdavid313.xyz/posts/notes-on-cl-web-services/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate><guid>https://macdavid313.xyz/posts/notes-on-cl-web-services/</guid><description>I’m recently finishing a Common Lisp web service used inside a company. An essential part of the reason why I choose Lisp in this case is, CLOS, one of the most powerful tools for designing complicated concepts. It’s a nice experience using CLOS to successfully solve some hard problems along with extending some components.
However, the embarrassing thing is I’ve never delivered a web application before, all I know is developing, debugging within SLIME and writing some scripts to deliver a binary executable so far.</description></item><item><title>Embedding Julia in Lisp</title><link>https://macdavid313.xyz/posts/embedding-julia-lisp/</link><pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate><guid>https://macdavid313.xyz/posts/embedding-julia-lisp/</guid><description>Julia is a high-level dynamic programming language designed to address the needs of high-performance numerical analysis and computational science while also being effective for general-purpose programming, web use or as a specification language1. I like its Lisp-like macros and multiple dispatch strategy. After all, it’s from MIT, where LISP happens. Its performance, according to this paper, is often within a factor of two relative to fully optimized C code (and thus often an order of magnitude faster than Python or R)2.</description></item><item><title>Common Lisp 中的 'map'</title><link>https://macdavid313.xyz/posts/common-lisp-map/</link><pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate><guid>https://macdavid313.xyz/posts/common-lisp-map/</guid><description>In many programming languages, map is the name of a higher-order function that applies a given function to each element of a list, returning a list of results in the same order. It is often called apply-to-all when considered in functional form. The concept of a map is not limited to lists: it works for sequential containers, tree-like containers, or even abstract containers such as futures and promises. —— Wikipedia1</description></item><item><title>A Brief Introduction to Common Lisp</title><link>https://macdavid313.xyz/posts/a-brief-intro-to-cl/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://macdavid313.xyz/posts/a-brief-intro-to-cl/</guid><description>This is a keynote that I made when I was studying at Mid Sweden University about one and half year ago. In a project course, every student was invited to give a presentation about what kind of tool or language been used for the project as the course’s first discussion session. This keynote is thus the one (but not the original one) I’d used to give a brief introduction about Common Lisp, which is used to build a simple academic paper recommendation system for the course.</description></item><item><title>Deliver Your Software by Producing a Single FASL File</title><link>https://macdavid313.xyz/posts/deliver-your-software-by-producing-a-single-fasl-f-c0e4ee80c7624909b5fd7cbc202c3056/</link><pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate><guid>https://macdavid313.xyz/posts/deliver-your-software-by-producing-a-single-fasl-f-c0e4ee80c7624909b5fd7cbc202c3056/</guid><description>From the very beginning, just like other ‘rookies’, I’m so confused why a Hello World executable file is so big in Common Lisp. Among all the implementations, of course you can argue that ECL can produce a small one, however, except in ECL, that binary file’s size is usually more than 30 MBs and even up to 50 MBs in the case of SBCL (on a 64bit platform).
It didn’t take too long till I realized it’s not fair to argue about that.</description></item></channel></rss>